<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BitCan: DIY Bitcoin Seed Storage</title>
    <style>
        :root {
            --background-gradient: radial-gradient(circle, white 0%, rgb(184, 183, 183) 100%);
            --box-shadow: 0 0.3em 0.4em rgba(0, 0, 0, 0.1);
            --light-grey-border: 0.1em solid #ccc;
            --font-family-monospace: 'Courier New', monospace;
        }

        body {
            font-family: Arial, sans-serif;
            padding: 0.6em;
            background: var(--background-gradient);
            max-width: 70em;
            margin: 0.3em auto;
        }

        h1 {
            margin: 1em 0;
            font-size: 1.5em;
        }

        .word-box {
            width: 2.5em;
            height: 7em;
            padding: 0.6em;
            margin: 0.2em auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(145deg, #ffffff, #e6e6e6);
            box-shadow: var(--box-shadow);
            border: var(--light-grey-border);
            border-radius: 0.5em;
        }

        .word-box.smaller {
            height: 6.2em;
            margin: 1em;
        }

        .content-container {
            display: flex;
            align-items: center;
            justify-content: space-around;
        }

        .word {
            font-family: var(--font-family-monospace);
            text-align: center;
            font-size: 0.7em;
        }

        .binary-string {
            font-family: var(--font-family-monospace);
            color: black;
            font-style: italic;
            font-size: 0.65em;
        }

        svg {
            width: 100%;
            display: block;
            overflow: visible;
            margin-top: 0.3em;
        }

        .centered-images {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5em;
        }

        .centered-images img {
            max-width: 15em;
            max-height: 15em;
            width: auto;
            height: auto;
            box-shadow: var(--box-shadow);
        }

        .strong-word-part {
            margin-right: 1px;
        }

        line.light {
            stroke: darkgrey;
            stroke-width: 0.5;
        }

        line.bold {
            stroke: black;
            stroke-width: 4;
        }

        .section-header {
            width: 100%;
            text-align: center;
            font-family: var(--font-family-monospace);
            font-size: 2em;
            font-weight: bold;
            border-bottom: var(--light-grey-border);
            line-height: normal;
            box-shadow: var(--box-shadow);
        }

        .section-header::after {
            display: inline-block;
            vertical-align: middle;
            background: white;
            position: relative;
        }

        .toc-item {
            display: inline-block;
            margin: 0 0.3em 0.9em;
            padding: 0.3em;
            width: 1.5em;
            border: var(--light-grey-border);
            border-radius: 0.3em;
            background-color: #f8f8f8;
            box-shadow: var(--box-shadow);
        }

        #wordsContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 0.3em;
            justify-content: center;
        }

        #tocContainer {
            text-align: center;
            margin-bottom: 1.2em;
        }

        @media print {
            body {
                background: none;
            }

            #tocContainer, .toc-item {
                display: none;
            }

            .word-box {
                background: white;
                box-shadow: none;
                page-break-inside: avoid;
                break-inside: avoid;
            }
        }
    </style>
</head>
<body>
<div>
    <div class="content-container">
        <div class="word-box smaller" id="animationContainer"></div>
        <article>
            <h1>BitCan: DIY Bitcoin Seed Storage</h1>
            <p>Welcome to BitCan, the resilient and economical solution for securing your <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank">Bitcoin mnemonic seed phrases</a>.</p>
            <p>Leveraging common materials and tools (i.e. beer can with screwdriver), BitCan offers a robust and lasting repository for Bitcoin wallet recovery information.</p>
            <p>Each glyph below corresponds to a word from the BIP39 list, the industry standard for wallet recovery seed generation, circumventing paper backup fragility and ensuring durability against physical adversity.</p>

            <details>
                <summary>Encoding Instructions</summary>
                <ol>
                    <li>Securely generate your mnemonic seed phrase using a trusted offline hardware wallet.</li>
                    <li>Transcribe your 12/24-word phrase onto paper, aligning the words with their corresponding glyphs.</li>
                    <li>Depict each glyph with precision, cross-referencing the list provided. Confirm accuracy by reading the sequence in reverse.</li>
                    <li>Transform a discarded beer can into a flat metal sheet.</li>
                    <li>On the metal, mark a grid for the glyphs uniformly, and sketch the designs lightly with a pencil.</li>
                    <li>Use a sturdy tool, like a screwdriver, to etch the glyphs onto the metal, tracing over your pencil lines.</li>
                    <li>Ensure each glyph is distinct and accurately corresponds to your BIP39 phrase. Test by decoding the glyphs.</li>
                    <li>Store the etched metal securely and discretely for safety and privacy.</li>
                </ol>
                <div class="centered-images">
                    <img src="img/IMG_3697.jpg" alt=""/>
                    <img src="img/IMG_3699.jpg" alt=""/>
                    <img src="img/IMG_3700.jpg" alt=""/>
                    <img src="img/IMG_3701.jpg" alt=""/>
                    <img src="img/IMG_3702.jpg" alt=""/>
                    <img src="img/IMG_3704.jpg" alt=""/>
                    <img src="img/IMG_3708.jpg" alt=""/>
                </div>
            </details>
            <details>
                <summary>Decoding Instructions</summary>
                <ol>
                    <li>Begin with your etched metal sheet that has all your glyphs.</li>
                    <li>For each glyph, focus on the last (11th) line position (the bottom horizontal line).</li>
                    <li>If the line is present, the corresponding word is in the second half of the BIP39 word list; if it's absent, it is in the first half.</li>
                    <li>Continue doing this for each line (binary search approach), moving from the rightmost line to the leftmost line of the glyph.</li>
                    <li>With each step, you divide the current section of the word list in half again, choosing the second half if the line is present and the first half if it is absent.</li>
                    <li>Repeat this process for each glyph until you have reconstructed your entire mnemonic seed phrase.</li>
                </ol>
            </details>

            <p>BitCan's inexpensive method provides enhanced protection for your wallet's seed phrase from threats like moisture and higher temperatures, with an added layer of security through obscurity.</p>
        </article>
    </div>
    <div id="tocContainer"></div>
    <div id="wordsContainer"></div>
</div>

<script>
    const wordsContainer = document.getElementById('wordsContainer');
    const tocContainer = document.getElementById('tocContainer');
    const width = 40;
    const height = 2 * width;
    const inset = 5;
    const lines = [
        [inset, 0, width - inset, 0],
        [0, inset, 0, width - inset],
        [inset, inset, width - inset, width - inset],
        [width - inset, inset, inset, width - inset],
        [width, inset, width, width - inset],

        [inset, width, width - inset, width],
        [0, width + inset, 0, height - inset],
        [inset, width + inset, width - inset, height - inset],
        [width - inset, width + inset, inset, height - inset],
        [width, width + inset, width, height - inset],

        [inset, height, width - inset, height],
    ];
    const binaryLength = lines.length;

    let currentIndex = 0;
    let direction = 1;

    function drawCurrent(animationContainer) {
        animationContainer.innerHTML = '';

        renderWordAndGlyph(animationContainer, "", 1 << currentIndex);

        currentIndex += direction;
        if (currentIndex === binaryLength - 1 || currentIndex === 0) {
            direction *= -1;
        }
    }

    setInterval(() => drawCurrent(document.getElementById('animationContainer')), 500);

    function asBinary(num) {
        return num.toString(2).padStart(binaryLength, '0');
    }

    function renderWordAndGlyph(container, word, index) {
        const wordElement = document.createElement('div');
        wordElement.className = 'word';

        if (word) {
            const strongElement = document.createElement('strong');
            strongElement.classList.add('strong-word-part');
            strongElement.textContent = word.substring(0, 4);
            wordElement.appendChild(strongElement);
            wordElement.appendChild(document.createTextNode(word.substring(4)));
            wordElement.appendChild(document.createElement('br'));
        }

        const binaryString = asBinary(index);
        const binaryStringElement = document.createElement('span');
        binaryStringElement.className = 'binary-string';
        binaryStringElement.innerHTML = binaryString.replaceAll('1', '<strong>1</strong>');
        wordElement.appendChild(binaryStringElement);

        container.appendChild(wordElement);

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        drawChar(svg, binaryString.split('').reverse().join(''));
        container.appendChild(svg);
    }

    function drawLine(svg, x1, y1, x2, y2, isBold) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke-linecap', 'round');
        line.classList.add(isBold ? 'bold' : 'light');
        svg.appendChild(line);
    }

    function drawChar(svg, binaryString) {
        const backgroundRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        backgroundRect.setAttribute('x', 0);
        backgroundRect.setAttribute('y', 0);
        backgroundRect.setAttribute('width', width);
        backgroundRect.setAttribute('height', height);
        backgroundRect.setAttribute('fill', 'OldLace');
        backgroundRect.setAttribute('rx', 3);

        // Append the rectangle as the first child of the SVG
        svg.appendChild(backgroundRect);

        "01".split('').forEach(char => {
            lines.forEach((points, index) => {
                if (binaryString[index] === char) {
                    drawLine(svg, points[0], points[1], points[2], points[3], char === '1');
                }
            });
        });
    }

    function fetchAndDisplayWords() {
        fetch('https://raw.githubusercontent.com/bitcoin/bips/master/bip-0039/english.txt')
            .then(response => response.text())
            .then(text => text.trim().split('\n'))
            .then(words => {
                let lastLetter = '';
                words.forEach((word, index) => {
                    word = word.toUpperCase();
                    if (word[0] !== lastLetter) {
                        lastLetter = word[0];

                        const sectionHeader = document.createElement('div');
                        sectionHeader.className = 'section-header';
                        sectionHeader.innerText = lastLetter;
                        wordsContainer.appendChild(sectionHeader);

                        const button = document.createElement('button');
                        button.className = "toc-item";
                        button.textContent = lastLetter;
                        button.onclick = () => sectionHeader.scrollIntoView({behavior: 'smooth', block: 'start'});
                        tocContainer.appendChild(button);
                    }

                    const wordBox = document.createElement('div');
                    wordBox.className = 'word-box';
                    renderWordAndGlyph(wordBox, word, asBinary(index));
                    wordsContainer.appendChild(wordBox);
                });
            });
    }

    fetchAndDisplayWords();
</script>
</body>
</html>
