<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BitCan: ‘Free as in Beer’ Bitcoin Seed Storage</title>
    <style>
        :root {
            --background-gradient: radial-gradient(circle, white 0%, rgb(184, 183, 183) 100%);
            --box-shadow: 0 5px 8px rgba(0, 0, 0, 0.1);
            --light-grey-border: 2px solid #ccc;
            --font-family-monospace: 'Courier New', monospace;
            --line-stroke-width: 0.5;
            --bold-line-stroke-width: 4;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 5px;
            padding: 10px;
            background: var(--background-gradient);
        }

        article {
            max-width: 800px;
            margin: 0 auto;
            font-size: 1rem;
        }

        .word-box {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(145deg, #ffffff, #e6e6e6);
            box-shadow: 0 5px 8px rgba(0, 0, 0, 0.1);
            border: 2px solid #ccc;
            border-radius: 10px;
            padding: 10px;
            margin: 5px;
            width: 50px;
        }

        .word {
            font-family: 'Courier New', monospace;
            text-align: center;
            font-size: 12px;
        }

        .binary-string {
            font-family: 'Courier New', monospace;
            color: Charcoal;
            font-style: italic;
            font-size: 8px;
        }

        svg {
            overflow: visible;
            margin-top: 5px;
            background: OldLace;
        }

        .strong-word-part {
            margin: 1px;
        }

        .leading-zeros {
            color: lightgrey;
        }

        line.light {
            stroke: darkgrey;
            stroke-width: 0.5;
        }

        line.bold {
            stroke: black;
            stroke-width: 4;
        }

        .section-header {
            width: 100%;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 25px;
            font-weight: bold;
            border-bottom: 1px solid #ccc;
            line-height: 0;
            margin: 20px 0 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 1);
        }

        .section-header::after {
            display: inline-block;
            vertical-align: middle;
            background: white;
            position: relative;
        }

        @media print {
            body {
                background: none;
            }

            .word-box {
                background: white;
                box-shadow: none;

                page-break-inside: avoid;
                break-inside: avoid;
            }
        }

        #wordsContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        #tocContainer {
            text-align: center;
            margin-bottom: 20px;
        }

        .toc-item {
            display: inline-block;
            margin: 0 5px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f8f8f8;
        }
    </style>
</head>
<body>
<div>
    <article>
        <h1>BitCan: ‘Free as in Beer’ Bitcoin Seed Storage</h1>
        <p>Welcome to BitCan, the resilient and economical solution for securing your <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank">BIP39 mnemonic seed
            phrases</a>.</p>
        <p>Leveraging common materials, BitCan offers a robust and lasting repository for Bitcoin wallet recovery information.</p>
        <p>Each glyph below corresponds to a word from the BIP39 list, the industry standard for wallet recovery seed generation, circumventing paper backup fragility and ensuring durability against
            physical adversity.</p>

        <details>
            <summary>Encoding Instructions</summary>
            <ol>
                <li>Securely generate your mnemonic seed phrase using a trusted offline hardware wallet.</li>
                <li>Transcribe your 12/24-word phrase onto paper, aligning the words with their corresponding glyphs.</li>
                <li>Depict each glyph with precision, cross-referencing the list provided. Confirm accuracy by reading the sequence in reverse.</li>
                <li>Transform a discarded beer can into a flat metal sheet.</li>
                <li>On the metal, mark a grid for the glyphs uniformly, and sketch the designs lightly with a pencil.</li>
                <li>Use a sturdy tool, like a screwdriver, to etch the glyphs onto the metal, tracing over your pencil lines.</li>
                <li>Ensure each glyph is distinct and accurately corresponds to your BIP39 phrase. Test by decoding the glyphs.</li>
                <li>Store the etched metal securely and discretely for safety and privacy.</li>
            </ol>
        </details>
        <details>
            <summary>Decoding Instructions</summary>
            <ol>
                <li>Begin with your etched metal sheet that has all your glyphs.</li>
                <li>For each glyph, focus on the last (11th) line position (the bottom vertical line).</li>
                <li>If the line is present, the corresponding word is in the second half of the BIP39 word list; if it's absent, it is in the first half.</li>
                <li>Continue doing this for each line (binary search approach), moving from the rightmost line to the leftmost line of the glyph.</li>
                <li>With each step, you divide the current section of the word list in half again, choosing the second half if the line is present and the first half if it is absent.</li>
                <li>Repeat this process for each glyph until you have reconstructed your entire mnemonic seed phrase.</li>
            </ol>
        </details>

        <p>BitCan's inexpensive method provides enhanced protection for your wallet's seed phrase from threats like moisture and higher temperatures, with an added layer of security through obscurity.</p>
    </article>

    <div id="tocContainer"></div>
    <div id="wordsContainer"></div>
</div>

<script>
    const wordsContainer = document.getElementById('wordsContainer');
    const tocContainer = document.getElementById('tocContainer');

    function drawLine(svg, x1, y1, x2, y2, isBold) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke-linecap', 'round');
        line.classList.add(isBold ? 'bold' : 'light');
        svg.appendChild(line);
    }

    function renderWordAndGlyph(container, word, index) {
        const binaryString = index.toString(2).padStart(11, '0');

        const wordElement = document.createElement('div');
        wordElement.className = 'word';

        const strongElement = document.createElement('strong');
        strongElement.classList.add('strong-word-part');
        strongElement.textContent = word.substring(0, 4);
        wordElement.appendChild(strongElement);

        const restOfWordText = document.createTextNode(word.substring(4));
        wordElement.appendChild(restOfWordText);

        const binaryStringElement = document.createElement('span');
        binaryStringElement.className = 'binary-string';

        const firstOneIndex = binaryString.indexOf('1');
        const leadingZeros = document.createElement('span');
        leadingZeros.classList.add('leading-zeros');
        leadingZeros.textContent = binaryString.substring(0, firstOneIndex);

        binaryStringElement.appendChild(leadingZeros);

        const restOfBinaryString = document.createTextNode(binaryString.substring(firstOneIndex));
        binaryStringElement.appendChild(restOfBinaryString);

        wordElement.appendChild(document.createElement('br'));
        wordElement.appendChild(binaryStringElement);

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', '0 0 50 100');
        drawChar(svg, binaryString.split('').reverse().join(''));

        container.appendChild(wordElement);
        container.appendChild(svg);
    }


    function drawChar(svg, binaryString) {
        const inset = 5;
        const lines = [
            [inset, 0, 50 - inset, 0],
            [0, inset, 0, 50 - inset],
            [inset, inset, 50 - inset, 50 - inset],
            [50 - inset, inset, inset, 50 - inset],
            [50, inset, 50, 50 - inset],

            [inset, 50, 50 - inset, 50],
            [0, 50 + inset, 0, 100 - inset],
            [inset, 50 + inset, 50 - inset, 100 - inset],
            [50 - inset, 50 + inset, inset, 100 - inset],
            [50, 50 + inset, 50, 100 - inset],

            [inset, 100, 50 - inset, 100],
        ];

        "01".split('').forEach(char => {
            lines.forEach((points, index) => {
                if (binaryString[index] === char) {
                    drawLine(svg, points[0], points[1], points[2], points[3], char === '1');
                }
            });
        });
    }

    function fetchAndDisplayWords() {
        fetch('https://raw.githubusercontent.com/bitcoin/bips/master/bip-0039/english.txt')
            .then(response => response.text())
            .then(text => text.trim().split('\n'))
            .then(words => {
                let lastLetter = '';
                words.forEach((word, index) => {
                    word = word.toUpperCase();
                    if (word[0] !== lastLetter) {
                        lastLetter = word[0];

                        const sectionHeader = document.createElement('div');
                        sectionHeader.className = 'section-header';
                        sectionHeader.innerText = lastLetter;
                        wordsContainer.appendChild(sectionHeader);

                        const button = document.createElement('button');
                        button.className = "toc-item";
                        button.textContent = lastLetter;
                        button.onclick = () => sectionHeader.scrollIntoView({behavior: 'smooth', block: 'start'});
                        tocContainer.appendChild(button);
                    }

                    const wordBox = document.createElement('div');
                    wordBox.className = 'word-box';
                    renderWordAndGlyph(wordBox, word, index.toString(2).padStart(11, '0'));
                    wordsContainer.appendChild(wordBox);
                });
            });
    }

    fetchAndDisplayWords();
</script>
</body>
</html>
